var D=Object.defineProperty;var B=(n,e,t)=>e in n?D(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var u=(n,e,t)=>B(n,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function t(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerPolicy&&(s.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?s.credentials="include":o.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(o){if(o.ep)return;o.ep=!0;const s=t(o);fetch(o.href,s)}})();const N=100,b=60,y=3,k=25,G=.3,M=50,P=50,S=9,$=12,F=10,I=3,_=3,H=.3,v=(n,e)=>Math.hypot(n.x-e.x,n.y-e.y),A=(n,e,t,r)=>{const o={};t.forEach(a=>{var l,d;a.owner===r&&(o[l=a.from]??(o[l]=[]),o[d=a.to]??(o[d]=[]),o[a.from].push(a.to),o[a.to].push(a.from))});const s=new Set([n]),i=[n];for(;i.length;){const a=i.shift();if(a===e)return!0;for(const l of o[a]??[])s.has(l)||(s.add(l),i.push(l))}return!1};class Y{constructor(e){u(this,"parent",new Map);u(this,"rank",new Map);e.forEach(t=>{this.parent.set(t,t),this.rank.set(t,0)})}find(e){const t=this.parent.get(e);return t!==e&&this.parent.set(e,this.find(t)),this.parent.get(e)}union(e,t){const[r,o]=[this.find(e),this.find(t)];return r===o?!1:(this.rank.get(r)<this.rank.get(o)?this.parent.set(r,o):(this.parent.set(o,r),this.rank.get(r)===this.rank.get(o)&&this.rank.set(r,this.rank.get(r)+1)),!0)}}const R=(n,e)=>{const t=e.flatMap((s,i)=>e.slice(i+1).map(a=>({from:s,to:a,weight:v(n[s],n[a])})));t.sort((s,i)=>s.weight-i.weight);const r=new Y(e),o=[];for(const{from:s,to:i}of t)r.union(s,i)&&o.push({from:s,to:i,currentFlow:0,capacity:50+Math.floor(Math.random()*50),owner:n[s].owner});return o},X=(n,e,t)=>n.map(r=>e.reduce((o,s,i)=>{const a=t(i,r)?0:1e4,l=v(r,s)+a;return l<o.score?{index:i,score:l}:o},{index:0,score:1/0}).index),W=(n,e)=>{const t=[];for(;t.length<k;){const r={x:Math.random()*(n-N)+N/2,y:Math.random()*(e-N)+N/2,id:t.length,currentEnergy:0,attitude:"neutral",owner:null,isEnergyTower:!1,socialConnections:[]};(t.length===0||t.every(o=>v(o,r)>b))&&t.push(r)}for(let r=0;r<y;r++)t[r].isEnergyTower=!0,t[r].owner=r;return t},U=n=>{for(let e=y;e<n.length;e++)for(let t=e+1;t<n.length;t++)Math.random()<G&&(n[e].socialConnections.push(t),n[t].socialConnections.push(e))},z=(n,e)=>{const t=[],r=n.filter(i=>i.isEnergyTower),o=n.filter(i=>!i.isEnergyTower);q(o,r,e,n);const s=j(n);return t.push(...s),t},q=(n,e,t,r)=>{const o=V(r),s=X(n,e,o);n.forEach((i,a)=>{const l=s[a];i.owner=l,t[l].nodesSuppliedTo.push(i.id)})},V=n=>{const e=Math.ceil(n.reduce((t,r)=>t+r.socialConnections.length,0)/y);return(t,r)=>n.filter(s=>s.owner===t).reduce((s,i)=>s+i.socialConnections.length,0)+r.socialConnections.length<=e*(1+H)};function j(n){const e=[];for(let t=0;t<y;t++){const r=n.filter(i=>i.owner===t);if(r.length<2)continue;const o=r.map(i=>i.id),s=R(n,o);for(const i of s)i.capacity=S+Math.floor(Math.random()*($-S)),i.owner=t,e.push(i)}return e}const K=n=>{const e=document.getElementById("playersContainer");e&&(e.innerHTML="",n.players.forEach((t,r)=>{const o=`
      <div class="player-info">
        <div class="player-header">
          <h3>Player ${r+1}</h3>
          <div class="player-energy">
            âš¡ <span id="p${r+1}Energy">${t.energy}</span>
          </div>
        </div>
        <div class="player-stats">
          <span>Gain: <span id="p${r+1}Gain">${t.energyGenerated}</span></span>
          <span>Drain: <span id="p${r+1}Drain">${t.energyDraining}</span></span>
          <span>Supplied: <span id="p${r+1}Supply">${t.nodesSuppliedTo.length}</span></span>
        </div>
      </div>
    `;e.insertAdjacentHTML("beforeend",o)}))},C=n=>{n.players.forEach((r,o)=>{const s=document.getElementById(`p${o+1}Energy`),i=document.getElementById(`p${o+1}Drain`),a=document.getElementById(`p${o+1}Gain`),l=document.getElementById(`p${o+1}Supply`);l&&(l.textContent=r.nodesSuppliedTo.reduce((h,f)=>h+n.nodes[f].socialConnections.length,0).toString()),s&&(s.textContent=r.energy.toString()),i&&(i.textContent=r.energyDraining.toString()),a&&(a.textContent=r.energyGenerated.toString());const d=document.getElementById(`p${o+1}Influence`);d&&(d.style.width="0%")});const e=document.getElementById("gameStatus");e&&(e.textContent=`Turn ${n.turn} - Player ${n.currentPlayer+1}`);const t=document.getElementById("nodeInfo");if(t){const r=n.selectedNode;r?t.innerHTML=`
        <div class="node-info-content">
          <strong>Node ${r.id}</strong><br>
          Owner: ${r.owner!==null?"Player "+(r.owner+1):"None"}<br>
          Energy: ${r.currentEnergy}/${r.socialConnections.length}<br>
          Attitude: <span class="attitude-${r.attitude}">${r.attitude}</span>
        </div>`:t.innerHTML='<div class="node-info">Click a node for details</div>'}},T=(n,e,t)=>t.nodes.find(r=>v({x:n,y:e},r)<25)||null,J=(n,e)=>{e.nodes.forEach(t=>{var r;(r=t.socialConnections)==null||r.forEach(o=>{const s=e.nodes.find(i=>i.id===o);s&&(n.strokeStyle="rgba(128, 128, 128, 0.4)",n.lineWidth=1,n.setLineDash([3,3]),n.beginPath(),n.moveTo(t.x,t.y),n.lineTo(s.x,s.y),n.stroke(),n.setLineDash([]))})})},Q=(n,e)=>{e.powerEdges.forEach(t=>{const r=e.nodes[t.from],o=e.nodes[t.to],s=e.players[t.owner].color;n.strokeStyle=s,n.lineWidth=Math.max(2,t.capacity/4),n.shadowColor=s,n.shadowBlur=5,n.beginPath(),n.moveTo(r.x,r.y),n.lineTo(o.x,o.y),n.stroke(),n.shadowColor="transparent",n.shadowBlur=0;const i=(r.x+o.x)/2,a=(r.y+o.y)/2;n.fillStyle="rgba(0,0,0,0.7)",n.beginPath(),n.roundRect(i-12,a-10,24,16,4),n.fill(),n.fillStyle="#fff",n.font="10px Arial",n.textAlign="center",n.fillText(`${t.currentFlow}/${t.capacity}`,i,a+3)})},Z=(n,e,t)=>{var a;const r=((a=e.socialConnections)==null?void 0:a.length)||1,o=10+r*2,s=e.owner!==null?t.players[e.owner].color:"#666";n.shadowColor="rgba(0, 0, 0, 0.3)",n.shadowBlur=5,n.shadowOffsetX=2,n.shadowOffsetY=2,n.fillStyle=e.isEnergyTower?"#fff":s,e.isEnergyTower?(n.beginPath(),n.arc(e.x,e.y,15,0,Math.PI*2),n.fill()):n.fillRect(e.x-o/2,e.y-o/2,o,o),n.shadowColor="transparent",n.shadowBlur=0,n.shadowOffsetX=0,n.shadowOffsetY=0,e.isEnergyTower||x(n,e.x,e.y+o/2+10,e.currentEnergy,r),n.fillStyle="#fff",n.font="12px Arial",n.textAlign="center",n.strokeStyle="#000",n.lineWidth=3;const i=e.isEnergyTower?`Player ${e.owner!==null?e.owner+1:"?"}`:`${e.currentEnergy}/${r}`;n.strokeText(i,e.x,e.y+4),n.fillText(i,e.x,e.y+4)},x=(n,e,t,r,o)=>{const a=e-(o-1)*5/2;for(let l=0;l<o;l++)n.beginPath(),n.arc(a+l*5,t,2,0,Math.PI*2),n.fillStyle=l<r?"#2ed573":"#555",n.fill()},ee=(n,e)=>{if(!e.dragStart)return;const t=e.players[e.currentPlayer].color;n.strokeStyle=t,n.lineWidth=3,n.setLineDash([5,5]),n.shadowColor=t,n.shadowBlur=5,n.beginPath(),n.moveTo(e.dragStart.x,e.dragStart.y),n.lineTo(e.mouseX||0,e.mouseY||0),n.stroke(),n.setLineDash([]),n.shadowColor="transparent",n.shadowBlur=0},te=(n,e,t,r,o="rgba(0, 0, 0, 0.9)")=>{n.font="12px Arial";const d=Math.max(...r.map(p=>n.measureText(p).width))+12*2,h=r.length*16+12*2;let f=e+15,g=t-h-10;f+d>n.canvas.width&&(f=e-d-15),g<0&&(g=t+15),n.fillStyle=o,n.shadowColor="rgba(0, 0, 0, 0.5)",n.shadowBlur=10,n.shadowOffsetX=2,n.shadowOffsetY=2,n.beginPath(),n.roundRect(f,g,d,h,8),n.fill(),n.shadowColor="transparent",n.shadowBlur=0,n.shadowOffsetX=0,n.shadowOffsetY=0,n.strokeStyle="rgba(255, 255, 255, 0.3)",n.lineWidth=1,n.stroke(),n.fillStyle="#fff",n.textAlign="left",r.forEach((p,L)=>{n.fillText(p,f+12,g+12+(L+1)*16)})},ne=(n,e)=>{var o,s;if(!e.mouseX||!e.mouseY)return;const t=T(e.mouseX,e.mouseY,e);if(!t)return;const r=t.isEnergyTower?[`Energy Tower #${t.id}`,`Owner: ${t.owner!==null?`Player ${t.owner+1}`:"None"}`,"Generates unlimited energy"]:[`Node #${t.id}`,`Owner: ${t.owner!==null?`Player ${t.owner+1}`:"None"}`,`Energy: ${t.currentEnergy}/${((o=t.socialConnections)==null?void 0:o.length)||1}`,`Attitude: ${t.attitude||"neutral"}`,`Connections: ${((s=t.socialConnections)==null?void 0:s.length)||0}`];te(n,e.mouseX,e.mouseY,r)},E=n=>{const e=n.canvas.getContext("2d");e&&(e.clearRect(0,0,n.canvas.width,n.canvas.height),J(e,n),Q(e,n),n.nodes.forEach(t=>Z(e,t,n)),ee(e,n),ne(e,n))};class re{constructor(){u(this,"canvas");u(this,"currentPlayer",0);u(this,"turn",1);u(this,"players",[]);u(this,"nodes",[]);u(this,"powerEdges",[]);u(this,"selectedNode",null);u(this,"dragStart",null);u(this,"gameOver",!1);u(this,"mouseX",0);u(this,"mouseY",0);u(this,"lastHoveredNode",null);u(this,"lastHoveredPowerline",null);this.canvas=w,this.players=Array.from({length:y},(e,t)=>({energy:M,color:`hsl(${t*360/y}, 100%, 50%)`,towerId:t,energyDraining:0,energyGenerated:P,nodesSuppliedTo:[]})),this.init()}init(){this.nodes=W(this.canvas.width,this.canvas.height),U(this.nodes),this.powerEdges=z(this.nodes,this.players),this.distributeInitialEnergy();const e=document.getElementById("victoryModal");e&&(e.style.display="none"),K(this),C(this),E(this)}nextTurn(){this.gameOver||(this.updateAttitudes(),this.currentPlayer=(this.currentPlayer+1)%this.players.length,this.turn++,this.players.forEach(e=>e.energy=Math.min(e.energy+e.energyGenerated-e.energyDraining,50)),C(this),E(this))}updateAttitudes(){this.nodes.forEach(e=>{if(e.isEnergyTower)return;const r=e.socialConnections.length-e.currentEnergy;r<=0?e.attitude="positive":r>I?e.attitude="negative":e.attitude="neutral"}),this.nodes.forEach(e=>{e.attitude==="negative"&&this.evaluateSabotageVotes(e)>=_&&this.performSabotage(e)})}evaluateSabotageVotes(e){let t=0;return e.attitude==="negative"&&(t+=1),e.attitude==="positive"&&(t-=1),e.socialConnections.forEach(r=>{const o=this.nodes[r];if(!o)return;const s=o.owner===e.owner;o.attitude==="positive"&&(t+=s?-1:1),o.attitude==="negative"&&(t+=s?1:-1)}),t}performSabotage(e){e.owner=null;const t=this.powerEdges.filter(i=>i.from===e.id||i.to===e.id);if(t.length===0)return;const r=new Map;t.forEach(i=>{r.has(i.owner)||r.set(i.owner,[]),r.get(i.owner).push(i)});let o=[],s=1/0;for(const[,i]of r.entries())i.length<s?(s=i.length,o=i):i.length===s&&o.push(...i);if(o.length>0){const i=o[Math.floor(Math.random()*o.length)],a=this.powerEdges.indexOf(i);this.removeEdge(a),console.log(`Sabotage! Node ${e.id} destroyed powerline of owner ${i.owner}.`)}}tryIncreaseNodeEnergy(e){const t=this.nodes[e];if(t.isEnergyTower||t.owner===null||t.currentEnergy==t.socialConnections.length)return!1;const r=this.findPlayerTower(t.owner);if(!r)return!1;let o=this.findPathToNode(r.id,e,t.owner),s=this.findBottleneck(o);return s===null&&(this.recalculateAllFlows(t.owner),o=this.findPathToNode(r.id,e,t.owner),s=this.findBottleneck(o),s===null)?!1:(this.increaseFlowAlongPath(o,1),t.currentEnergy=(t.currentEnergy||0)+1,this.updatePlayerStats(),!0)}tryDecreaseNodeEnergy(e){const t=this.nodes[e];if(t.isEnergyTower||t.owner===null||!t.currentEnergy)return!1;const r=this.findPlayerTower(t.owner);if(!r)return!1;const o=this.findPathToNode(r.id,e,t.owner);return o.length?(this.decreaseFlowAlongPath(o,1),t.currentEnergy=Math.max(0,t.currentEnergy-1),this.updatePlayerStats(),!0):!1}tryConstructEdge(e,t,r,o,s){const i=this.nodes[t],a=this.players[r];if(a.energy<s)return!1;if(i.owner===null)return i.owner=r,this.createEdge(e,t,r,o),a.energy-=s,this.updatePlayerStats(),!0;if(i.owner===r)return this.createEdge(e,t,r,o),a.energy-=s,!0;{const l=i.currentEnergy||0,d=i.socialConnections.length;if(l>d/2)return!1;{const h=i.owner;return this.disconnectNodeFromOwner(i.id,h),i.owner=r,i.currentEnergy=0,this.createEdge(e,t,r,o),a.energy-=s,this.findDisconnectedNodesAfterNodeLoss(i.id,h).forEach(g=>{const p=this.nodes[g];p.owner=null,p.currentEnergy=0}),this.recalculateAllFlows(h),this.recalculateAllFlows(r),this.updatePlayerStats(),!0}}}removeEdge(e){const t=this.powerEdges[e],r=t.owner;this.findDisconnectedNodes(t,r).forEach(s=>{const i=this.nodes[s];i.owner===r&&!i.isEnergyTower&&(i.currentEnergy=0,this.redistributeEnergyAfterDisconnection(s,r))}),this.powerEdges.splice(e,1),this.updatePlayerStats()}findDisconnectedNodesAfterNodeLoss(e,t){const r=this.findPlayerTower(t);if(!r)return[];const o=this.powerEdges.filter(a=>a.owner===t),s=new Set,i=[r.id];for(;i.length>0;){const a=i.shift();s.add(a);for(const l of o)l.from===a&&l.to!==e&&!s.has(l.to)?i.push(l.to):l.to===a&&l.from!==e&&!s.has(l.from)&&i.push(l.from)}return this.nodes.map((a,l)=>({node:a,id:l})).filter(({node:a,id:l})=>a.owner===t&&!a.isEnergyTower&&!s.has(l)).map(({id:a})=>a)}findPlayerTower(e){return this.nodes.find(t=>t.isEnergyTower&&t.owner===e)||null}findPathToNode(e,t,r){const o=this.powerEdges.filter(l=>l.owner===r);if(!A(e,t,o,r))return[];const s=new Map;o.forEach(l=>{s.has(l.from)||s.set(l.from,[]),s.has(l.to)||s.set(l.to,[]),s.get(l.from).push(l),s.get(l.to).push(l)});const i=[{nodeId:e,path:[]}],a=new Set([e]);for(;i.length>0;){const{nodeId:l,path:d}=i.shift();if(l===t)return d;for(const h of s.get(l)||[]){const f=h.from===l?h.to:h.from;a.has(f)||(a.add(f),i.push({nodeId:f,path:[...d,h]}))}}return[]}findBottleneck(e){for(const t of e)if(t.currentFlow>=t.capacity)return null;return Math.min(...e.map(t=>t.capacity-t.currentFlow))}increaseFlowAlongPath(e,t){e.forEach(r=>{r.currentFlow=Math.min(r.capacity,r.currentFlow+t)})}decreaseFlowAlongPath(e,t){e.forEach(r=>{r.currentFlow=Math.max(0,r.currentFlow-t)})}createEdge(e,t,r,o){this.powerEdges.push({from:e,to:t,owner:r,capacity:o,currentFlow:0})}disconnectNodeFromOwner(e,t){const r=this.findPlayerTower(t);if(!r)return;const o=this.findPathToNode(r.id,e,t);if(o.length===0)return;const i=this.nodes[e].currentEnergy||0;this.decreaseFlowAlongPath(o,i)}findDisconnectedNodes(e,t){const r=this.powerEdges.filter(a=>a!==e&&a.owner===t),o=this.findPlayerTower(t);if(!o)return[];const s=[],i=this.nodes.map((a,l)=>({node:a,id:l})).filter(({node:a})=>a.owner===t&&!a.isEnergyTower);for(const{id:a}of i)A(o.id,a,r,t)||s.push(a);return s}redistributeEnergyAfterDisconnection(e,t){this.recalculateAllFlows(t)}recalculateAllFlows(e){const t=this.findPlayerTower(e);if(!t)return;const r=this.powerEdges.filter(s=>s.owner===e),o=this.nodes.filter(s=>s.owner===e&&!s.isEnergyTower);r.forEach(s=>s.currentFlow=0);for(const s of o){const i=s.currentEnergy||0;if(i>0){const a=this.findPathToNode(t.id,s.id,e);a.length>0&&this.increaseFlowAlongPath(a,i)}}}updatePlayerStats(){this.players.forEach(e=>{e.nodesSuppliedTo=[],e.energyDraining=0,e.energyGenerated=0,this.nodes.forEach((r,o)=>{r.owner===e.towerId&&!r.isEnergyTower&&(e.nodesSuppliedTo.push(o),e.energyDraining+=r.currentEnergy||0)});const t=this.nodes.filter(r=>r.isEnergyTower&&r.owner===e.towerId);e.energyGenerated=t.length*P})}distributeInitialEnergy(){const e=new Map;this.nodes.forEach((t,r)=>{t.owner!==null&&!t.isEnergyTower&&(e.has(t.owner)||e.set(t.owner,[]),e.get(t.owner).push({...t,id:r}))});for(const[t,r]of e){const o=r.reduce((a,l)=>a+l.socialConnections.length,0);if(o===0)continue;const i=this.nodes.filter(a=>a.isEnergyTower&&a.owner===t).length*P;r.forEach(a=>{const l=a.socialConnections.length/o,d=Math.min(Math.floor(i*l),a.socialConnections.length),h=this.nodes[a.id];h.currentEnergy=0;for(let f=0;f<d&&this.tryIncreaseNodeEnergy(a.id);f++);})}}newGame(){this.currentPlayer=0,this.turn=1,this.selectedNode=null,this.dragStart=null,this.gameOver=!1,this.mouseX=0,this.mouseY=0,this.lastHoveredNode=null,this.lastHoveredPowerline=null,this.players=Array.from({length:y},(e,t)=>({energy:M,color:`hsl(${t*360/y}, 100%, 50%)`,towerId:t,energyDraining:0,energyGenerated:P,nodesSuppliedTo:[]})),this.init()}}function m(n,e){const t=e.getBoundingClientRect();return{x:n.clientX-t.left,y:n.clientY-t.top}}function oe(n,e,t){return t.find(r=>r.from===n&&r.to===e||r.from===e&&r.to===n)}function se(n,e,t){const r=n.players[n.currentPlayer],o=r.towerId;A(o,e.id,n.powerEdges,n.currentPlayer)&&(t&&e.currentEnergy>0?n.tryDecreaseNodeEnergy(e.id):!t&&r.energy>0&&n.tryIncreaseNodeEnergy(e.id))}function O(n,e,t=!1){if(!e||e.gameOver)return;const{x:r,y:o}=m(n,e.canvas),s=T(r,o,e);s&&(e.selectedNode=s,s.isEnergyTower||se(e,s,t)),C(e),E(e)}function ie(n,e){if(!e||e.gameOver)return;const{x:t,y:r}=m(n,e.canvas),o=T(t,r,e);o&&(e.dragStart=o)}function ae(n,e){if(!e)return;const{x:t,y:r}=m(n,e.canvas);e.mouseX=t,e.mouseY=r;const o=T(t,r,e),s=e.lastHoveredNode||e.lastHoveredPowerline;e.lastHoveredNode=o,o?e.canvas.style.cursor="pointer":e.dragStart?e.canvas.style.cursor="grabbing":e.canvas.style.cursor="default",(e.dragStart||o||s)&&E(e)}function le(n,e,t){const r=n.players[n.currentPlayer],o=v(e,t),s=$-S,i=S+Math.floor(Math.random()*s),a=Math.floor(o/F)+i;if(r.energy<a)return;const l=oe(e.id,t.id,n.powerEdges);l?l.owner===n.currentPlayer&&(l.capacity+=i,r.energy-=a):n.tryConstructEdge(e.id,t.id,n.currentPlayer,i,a)}function ce(n,e){if(!e||e.gameOver||!e.dragStart)return;const{x:t,y:r}=m(n,e.canvas),o=T(t,r,e);o&&o!==e.dragStart&&le(e,e.dragStart,o),e.dragStart=null,e.canvas.style.cursor="default",C(e),E(e)}const w=document.getElementById("gameCanvas");let c=null;window.onload=()=>{const n=()=>{w.width=w.clientWidth,w.height=w.clientHeight,c!=null&&c.nodes&&c.nodes.length>0&&E(c)};window.addEventListener("resize",n),n(),w.addEventListener("click",e=>O(e,c)),w.addEventListener("contextmenu",e=>{e.preventDefault(),O(e,c,!0)}),w.addEventListener("mousedown",e=>ie(e,c)),w.addEventListener("mousemove",e=>ae(e,c)),w.addEventListener("mouseup",e=>ce(e,c)),de()};function de(){c=new re;const n=document.getElementById("endTurnBtn"),e=document.getElementById("newGameBtn"),t=document.getElementById("anewGameBtn");n&&n.addEventListener("click",()=>c==null?void 0:c.nextTurn()),e&&e.addEventListener("click",()=>c==null?void 0:c.newGame()),t&&t.addEventListener("click",()=>c==null?void 0:c.newGame())}
