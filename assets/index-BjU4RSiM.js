var Y=Object.defineProperty;var R=(n,e,t)=>e in n?Y(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var w=(n,e,t)=>R(n,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function t(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerPolicy&&(s.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?s.credentials="include":o.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(o){if(o.ep)return;o.ep=!0;const s=t(o);fetch(o.href,s)}})();const S=100,X=60,g=Math.floor(Math.random()*3)+3,W=Math.floor(Math.random()*25)+25,U=.3,I=50,m=50,M=9,G=12,V=10,z=3,q=3,L=.3,T=(n,e)=>Math.hypot(n.x-e.x,n.y-e.y),B=(n,e,t,r)=>{const o={};t.forEach(l=>{var a,c;l.owner===r&&(o[a=l.from]??(o[a]=[]),o[c=l.to]??(o[c]=[]),o[l.from].push(l.to),o[l.to].push(l.from))});const s=new Set([n]),i=[n];for(;i.length;){const l=i.shift();if(l===e)return!0;for(const a of o[l]??[])s.has(a)||(s.add(a),i.push(a))}return!1};class j{constructor(e){w(this,"parent",new Map);w(this,"rank",new Map);e.forEach(t=>{this.parent.set(t,t),this.rank.set(t,0)})}find(e){const t=this.parent.get(e);return t!==e&&this.parent.set(e,this.find(t)),this.parent.get(e)}union(e,t){const[r,o]=[this.find(e),this.find(t)];return r===o?!1:(this.rank.get(r)<this.rank.get(o)?this.parent.set(r,o):(this.parent.set(o,r),this.rank.get(r)===this.rank.get(o)&&this.rank.set(r,this.rank.get(r)+1)),!0)}}const K=(n,e)=>{const t=e.flatMap((s,i)=>e.slice(i+1).map(l=>({from:s,to:l,weight:T(n[s],n[l])})));t.sort((s,i)=>s.weight-i.weight);const r=new j(e),o=[];for(const{from:s,to:i}of t)r.union(s,i)&&o.push({from:s,to:i,currentFlow:0,capacity:50+Math.floor(Math.random()*50),owner:n[s].owner});return o},J=(n,e,t)=>n.map(r=>e.reduce((o,s,i)=>{const l=t(i,r)?0:1e4,a=T(r,s)+l;return a<o.score?{index:i,score:a}:o},{index:0,score:1/0}).index),Q=(n,e,t)=>{const r=J(n,e,t),o=Array(e.length).fill(null).map(()=>[]);r.forEach((l,a)=>{o[l].push(n[a])});const i=n.reduce((l,a)=>l+a.socialConnections.reduce((c,d)=>c+d,0),0)/e.length;for(let l=0;l<10;l++){const a=o.map(h=>h.reduce((v,D)=>v+D.socialConnections.reduce((b,$)=>b+$,0),0)),c=a.findIndex(h=>h>i*(1+L)),d=a.findIndex(h=>h<i*(1-L));if(c===-1||d===-1)break;const f=e[c],E=e[d],p=o[c].filter(h=>t(d,h)).map(h=>{const v=h.socialConnections.reduce((H,_)=>H+_,0),D=T(h,f),$=T(h,E)-D;return{node:h,weight:v,distanceDiff:$}}).sort((h,v)=>h.distanceDiff!==v.distanceDiff?h.distanceDiff-v.distanceDiff:h.weight-v.weight);if(p.length===0)break;const N=p[0].node;o[c]=o[c].filter(h=>h!==N),o[d].push(N);const F=n.indexOf(N);r[F]=d}return r},Z=(n,e)=>{const t=[];for(;t.length<W;){const r={x:Math.random()*(n-S)+S/2,y:Math.random()*(e-S)+S/2,id:t.length,currentEnergy:0,attitude:"neutral",owner:null,isEnergyTower:!1,socialConnections:[]};(t.length===0||t.every(o=>T(o,r)>X))&&t.push(r)}for(let r=0;r<g;r++)t[r].isEnergyTower=!0,t[r].owner=r;return t},x=n=>{for(let e=g;e<n.length;e++)for(let t=e+1;t<n.length;t++)Math.random()<U&&(n[e].socialConnections.push(t),n[t].socialConnections.push(e))},ee=(n,e)=>{const t=[],r=n.filter(i=>i.isEnergyTower),o=n.filter(i=>!i.isEnergyTower);te(o,r,e,n);const s=re(n);return t.push(...s),t},te=(n,e,t,r)=>{const o=ne(r),s=Q(n,e,o);n.forEach((i,l)=>{const a=s[l];i.owner=a,t[a].nodesSuppliedTo.push(i.id)})},ne=n=>{const e=Math.ceil(n.reduce((t,r)=>t+r.socialConnections.reduce((o,s)=>o+s,0),0)/g);return(t,r)=>n.filter(s=>s.owner===t).reduce((s,i)=>s+i.socialConnections.reduce((l,a)=>l+a,0),0)+r.socialConnections.length<=e*(1+L)};function re(n){const e=[];for(let t=0;t<g;t++){const r=n.filter(i=>i.owner===t);if(r.length<2)continue;const o=r.map(i=>i.id),s=K(n,o);for(const i of s)i.capacity=M+Math.floor(Math.random()*(G-M)),i.owner=t,e.push(i)}return e}const oe=n=>{const e=document.getElementById("playersContainer");e&&(e.innerHTML="",n.players.forEach((t,r)=>{const o=`
      <div class="player-info">
        <div class="player-header">
          <h3>Player ${r+1}</h3>
          <div class="player-energy">
            ‚ö° <span id="p${r+1}Energy">${t.energy}</span>
          </div>
        </div>
        <div class="player-stats">
          <span>Gain: <span id="p${r+1}Gain">${t.energyGenerated}</span></span>
          <span>Drain: <span id="p${r+1}Drain">${t.energyDraining}</span></span>
          <span>Supplied: <span id="p${r+1}Supply">${t.nodesSuppliedTo.length}</span></span>
        </div>
      </div>
    `;e.insertAdjacentHTML("beforeend",o)}))},A=n=>{n.players.forEach((r,o)=>{const s=document.getElementById(`p${o+1}Energy`),i=document.getElementById(`p${o+1}Drain`),l=document.getElementById(`p${o+1}Gain`),a=document.getElementById(`p${o+1}Supply`);a&&(a.textContent=r.nodesSuppliedTo.reduce((d,f)=>d+n.nodes[f].socialConnections.length,0).toString()),s&&(s.textContent=r.energy.toString()),i&&(i.textContent=r.energyDraining.toString()),l&&(l.textContent=r.energyGenerated.toString());const c=document.getElementById(`p${o+1}Influence`);c&&(c.style.width="0%")});const e=document.getElementById("gameStatus");e&&(e.textContent=`Turn ${n.turn} - Player ${n.currentPlayer+1}`);const t=document.getElementById("nodeInfo");if(t){const r=n.selectedNode;r?t.innerHTML=`
        <div class="node-info-content">
          <strong>Node ${r.id}</strong><br>
          Owner: ${r.owner!==null?"Player "+(r.owner+1):"None"}<br>
          Energy: ${r.currentEnergy}/${r.socialConnections.length}<br>
          Attitude: <span class="attitude-${r.attitude}">${r.attitude}</span>
        </div>`:t.innerHTML='<div class="node-info">Click a node for details</div>'}},se=n=>{const e=document.getElementById("victoryModal"),t=document.getElementById("victoryText");t&&(t.innerHTML=`üèÜ Player ${n+1} Wins! üèÜ<br>Controlled 60% of city influence!`),e&&(e.style.display="block")},P=(n,e,t)=>t.nodes.find(r=>T({x:n,y:e},r)<25)||null,ie=(n,e)=>{e.nodes.forEach(t=>{var r;(r=t.socialConnections)==null||r.forEach(o=>{const s=e.nodes.find(i=>i.id===o);s&&(n.strokeStyle="rgba(128, 128, 128, 0.4)",n.lineWidth=1,n.setLineDash([3,3]),n.beginPath(),n.moveTo(t.x,t.y),n.lineTo(s.x,s.y),n.stroke(),n.setLineDash([]))})})},le=(n,e)=>{e.powerEdges.forEach(t=>{const r=e.nodes[t.from],o=e.nodes[t.to],s=e.players[t.owner].color;n.strokeStyle=s,n.lineWidth=Math.max(2,t.capacity/4),n.shadowColor=s,n.shadowBlur=5,n.beginPath(),n.moveTo(r.x,r.y),n.lineTo(o.x,o.y),n.stroke(),n.shadowColor="transparent",n.shadowBlur=0;const i=(r.x+o.x)/2,l=(r.y+o.y)/2;n.fillStyle="rgba(0,0,0,0.7)",n.beginPath(),n.roundRect(i-12,l-10,24,16,4),n.fill(),n.fillStyle="#fff",n.font="10px Arial",n.textAlign="center",n.fillText(`${t.currentFlow}/${t.capacity}`,i,l+3)})},ae=(n,e,t)=>{var l;const r=((l=e.socialConnections)==null?void 0:l.length)||1,o=10+r*2,s=e.owner!==null?t.players[e.owner].color:"#666";n.shadowColor="rgba(0, 0, 0, 0.3)",n.shadowBlur=5,n.shadowOffsetX=2,n.shadowOffsetY=2,n.fillStyle=e.isEnergyTower?"#fff":s,e.isEnergyTower?(n.beginPath(),n.arc(e.x,e.y,15,0,Math.PI*2),n.fill()):n.fillRect(e.x-o/2,e.y-o/2,o,o),n.shadowColor="transparent",n.shadowBlur=0,n.shadowOffsetX=0,n.shadowOffsetY=0,e.isEnergyTower||ce(n,e.x,e.y+o/2+10,e.currentEnergy,r),n.fillStyle="#fff",n.font="12px Arial",n.textAlign="center",n.strokeStyle="#000",n.lineWidth=3;const i=e.isEnergyTower?`Player ${e.owner!==null?e.owner+1:"?"}`:`${e.currentEnergy}/${r}`;n.strokeText(i,e.x,e.y+4),n.fillText(i,e.x,e.y+4)},ce=(n,e,t,r,o)=>{const l=e-(o-1)*5/2;for(let a=0;a<o;a++)n.beginPath(),n.arc(l+a*5,t,2,0,Math.PI*2),n.fillStyle=a<r?"#2ed573":"#555",n.fill()},de=(n,e)=>{if(!e.dragStart)return;const t=e.players[e.currentPlayer].color;n.strokeStyle=t,n.lineWidth=3,n.setLineDash([5,5]),n.shadowColor=t,n.shadowBlur=5,n.beginPath(),n.moveTo(e.dragStart.x,e.dragStart.y),n.lineTo(e.mouseX||0,e.mouseY||0),n.stroke(),n.setLineDash([]),n.shadowColor="transparent",n.shadowBlur=0},ue=(n,e,t,r,o="rgba(0, 0, 0, 0.9)")=>{n.font="12px Arial";const c=Math.max(...r.map(p=>n.measureText(p).width))+12*2,d=r.length*16+12*2;let f=e+15,E=t-d-10;f+c>n.canvas.width&&(f=e-c-15),E<0&&(E=t+15),n.fillStyle=o,n.shadowColor="rgba(0, 0, 0, 0.5)",n.shadowBlur=10,n.shadowOffsetX=2,n.shadowOffsetY=2,n.beginPath(),n.roundRect(f,E,c,d,8),n.fill(),n.shadowColor="transparent",n.shadowBlur=0,n.shadowOffsetX=0,n.shadowOffsetY=0,n.strokeStyle="rgba(255, 255, 255, 0.3)",n.lineWidth=1,n.stroke(),n.fillStyle="#fff",n.textAlign="left",r.forEach((p,N)=>{n.fillText(p,f+12,E+12+(N+1)*16)})},he=(n,e)=>{var o,s;if(!e.mouseX||!e.mouseY)return;const t=P(e.mouseX,e.mouseY,e);if(!t)return;const r=t.isEnergyTower?[`Energy Tower #${t.id}`,`Owner: ${t.owner!==null?`Player ${t.owner+1}`:"None"}`,"Generates unlimited energy"]:[`Node #${t.id}`,`Owner: ${t.owner!==null?`Player ${t.owner+1}`:"None"}`,`Energy: ${t.currentEnergy}/${((o=t.socialConnections)==null?void 0:o.length)||1}`,`Attitude: ${t.attitude||"neutral"}`,`Connections: ${((s=t.socialConnections)==null?void 0:s.length)||0}`];ue(n,e.mouseX,e.mouseY,r)},C=n=>{const e=n.canvas.getContext("2d");e&&(e.clearRect(0,0,n.canvas.width,n.canvas.height),ie(e,n),le(e,n),n.nodes.forEach(t=>ae(e,t,n)),de(e,n),he(e,n))};class fe{constructor(){w(this,"canvas");w(this,"currentPlayer",0);w(this,"turn",1);w(this,"players",[]);w(this,"nodes",[]);w(this,"powerEdges",[]);w(this,"selectedNode",null);w(this,"dragStart",null);w(this,"gameOver",!1);w(this,"mouseX",0);w(this,"mouseY",0);w(this,"lastHoveredNode",null);w(this,"lastHoveredPowerline",null);this.canvas=y,this.players=Array.from({length:g},(e,t)=>({energy:I,color:`hsl(${t*360/g}, 100%, 50%)`,towerId:t,energyDraining:0,energyGenerated:m,nodesSuppliedTo:[]})),this.init()}init(){this.nodes=Z(this.canvas.width,this.canvas.height),x(this.nodes),this.powerEdges=ee(this.nodes,this.players),this.distributeInitialEnergy();const e=document.getElementById("victoryModal");e&&(e.style.display="none"),oe(this),A(this),C(this)}nextTurn(){this.gameOver||(this.updateAttitudes(),this.currentPlayer=(this.currentPlayer+1)%this.players.length,this.turn++,this.players.forEach(e=>e.energy=Math.min(e.energy+e.energyGenerated-e.energyDraining,50)),this.checkVictoryCondition(),A(this),C(this))}updateAttitudes(){this.nodes.forEach(e=>{if(e.isEnergyTower)return;const r=e.socialConnections.length-e.currentEnergy;r<=0?e.attitude="positive":r>z?e.attitude="negative":e.attitude="neutral"}),this.nodes.forEach(e=>{e.attitude==="negative"&&this.evaluateSabotageVotes(e)>=q&&this.performSabotage(e)})}evaluateSabotageVotes(e){let t=0;return e.attitude==="negative"&&(t+=1),e.attitude==="positive"&&(t-=1),e.socialConnections.forEach(r=>{const o=this.nodes[r];if(!o)return;const s=o.owner===e.owner;o.attitude==="positive"&&(t+=s?-1:1),o.attitude==="negative"&&(t+=s?1:-1)}),t}performSabotage(e){e.owner=null;const t=this.powerEdges.filter(i=>i.from===e.id||i.to===e.id);if(t.length===0)return;const r=new Map;t.forEach(i=>{r.has(i.owner)||r.set(i.owner,[]),r.get(i.owner).push(i)});let o=[],s=1/0;for(const[,i]of r.entries())i.length<s?(s=i.length,o=i):i.length===s&&o.push(...i);if(o.length>0){const i=o[Math.floor(Math.random()*o.length)],l=this.powerEdges.indexOf(i);this.removeEdge(l),console.log(`Sabotage! Node ${e.id} destroyed powerline of owner ${i.owner}.`)}}tryIncreaseNodeEnergy(e){const t=this.nodes[e];if(t.isEnergyTower||t.owner===null||t.currentEnergy==t.socialConnections.length)return!1;const r=this.findPlayerTower(t.owner);if(!r)return!1;let o=this.findPathToNode(r.id,e,t.owner),s=this.findBottleneck(o);return s===null&&(this.recalculateAllFlows(t.owner),o=this.findPathToNode(r.id,e,t.owner),s=this.findBottleneck(o),s===null)?!1:(this.increaseFlowAlongPath(o,1),t.currentEnergy=(t.currentEnergy||0)+1,this.updatePlayerStats(),!0)}tryDecreaseNodeEnergy(e){const t=this.nodes[e];if(t.isEnergyTower||t.owner===null||!t.currentEnergy)return!1;const r=this.findPlayerTower(t.owner);if(!r)return!1;const o=this.findPathToNode(r.id,e,t.owner);return o.length?(this.decreaseFlowAlongPath(o,1),t.currentEnergy=Math.max(0,t.currentEnergy-1),this.updatePlayerStats(),!0):!1}tryConstructEdge(e,t,r,o,s){const i=this.nodes[t],l=this.players[r];if(l.energy<s)return!1;if(i.owner===null)return i.owner=r,this.createEdge(e,t,r,o),l.energy-=s,this.updatePlayerStats(),!0;if(i.owner===r)return this.createEdge(e,t,r,o),l.energy-=s,!0;{const a=i.currentEnergy||0,c=i.socialConnections.length;if(a>c/2)return!1;{const d=i.owner;return this.disconnectNodeFromOwner(i.id,d),i.owner=r,i.currentEnergy=0,this.createEdge(e,t,r,o),l.energy-=s,this.findDisconnectedNodesAfterNodeLoss(i.id,d).forEach(E=>{const p=this.nodes[E];p.owner=null,p.currentEnergy=0}),this.recalculateAllFlows(d),this.recalculateAllFlows(r),this.updatePlayerStats(),!0}}}removeEdge(e){const t=this.powerEdges[e],r=t.owner;this.findDisconnectedNodes(t,r).forEach(s=>{const i=this.nodes[s];i.owner===r&&!i.isEnergyTower&&(i.currentEnergy=0,this.redistributeEnergyAfterDisconnection(s,r))}),this.powerEdges.splice(e,1),this.updatePlayerStats()}findDisconnectedNodesAfterNodeLoss(e,t){const r=this.findPlayerTower(t);if(!r)return[];const o=this.powerEdges.filter(l=>l.owner===t),s=new Set,i=[r.id];for(;i.length>0;){const l=i.shift();s.add(l);for(const a of o)a.from===l&&a.to!==e&&!s.has(a.to)?i.push(a.to):a.to===l&&a.from!==e&&!s.has(a.from)&&i.push(a.from)}return this.nodes.map((l,a)=>({node:l,id:a})).filter(({node:l,id:a})=>l.owner===t&&!l.isEnergyTower&&!s.has(a)).map(({id:l})=>l)}findPlayerTower(e){return this.nodes.find(t=>t.isEnergyTower&&t.owner===e)||null}findPathToNode(e,t,r){const o=this.powerEdges.filter(a=>a.owner===r);if(!B(e,t,o,r))return[];const s=new Map;o.forEach(a=>{s.has(a.from)||s.set(a.from,[]),s.has(a.to)||s.set(a.to,[]),s.get(a.from).push(a),s.get(a.to).push(a)});const i=[{nodeId:e,path:[]}],l=new Set([e]);for(;i.length>0;){const{nodeId:a,path:c}=i.shift();if(a===t)return c;for(const d of s.get(a)||[]){const f=d.from===a?d.to:d.from;l.has(f)||(l.add(f),i.push({nodeId:f,path:[...c,d]}))}}return[]}findBottleneck(e){for(const t of e)if(t.currentFlow>=t.capacity)return null;return Math.min(...e.map(t=>t.capacity-t.currentFlow))}increaseFlowAlongPath(e,t){e.forEach(r=>{r.currentFlow=Math.min(r.capacity,r.currentFlow+t)})}decreaseFlowAlongPath(e,t){e.forEach(r=>{r.currentFlow=Math.max(0,r.currentFlow-t)})}createEdge(e,t,r,o){this.powerEdges.push({from:e,to:t,owner:r,capacity:o,currentFlow:0})}disconnectNodeFromOwner(e,t){const r=this.findPlayerTower(t);if(!r)return;const o=this.findPathToNode(r.id,e,t);if(o.length===0)return;const i=this.nodes[e].currentEnergy||0;this.decreaseFlowAlongPath(o,i)}findDisconnectedNodes(e,t){const r=this.powerEdges.filter(l=>l!==e&&l.owner===t),o=this.findPlayerTower(t);if(!o)return[];const s=[],i=this.nodes.map((l,a)=>({node:l,id:a})).filter(({node:l})=>l.owner===t&&!l.isEnergyTower);for(const{id:l}of i)B(o.id,l,r,t)||s.push(l);return s}redistributeEnergyAfterDisconnection(e,t){this.recalculateAllFlows(t)}recalculateAllFlows(e){const t=this.findPlayerTower(e);if(!t)return;const r=this.powerEdges.filter(s=>s.owner===e),o=this.nodes.filter(s=>s.owner===e&&!s.isEnergyTower);r.forEach(s=>s.currentFlow=0);for(const s of o){const i=s.currentEnergy||0;if(i>0){const l=this.findPathToNode(t.id,s.id,e);l.length>0&&this.increaseFlowAlongPath(l,i)}}}updatePlayerStats(){this.players.forEach(e=>{e.nodesSuppliedTo=[],e.energyDraining=0,e.energyGenerated=0,this.nodes.forEach((r,o)=>{r.owner===e.towerId&&!r.isEnergyTower&&(e.nodesSuppliedTo.push(o),e.energyDraining+=r.currentEnergy||0)});const t=this.nodes.filter(r=>r.isEnergyTower&&r.owner===e.towerId);e.energyGenerated=t.length*m})}distributeInitialEnergy(){const e=new Map;this.nodes.forEach((t,r)=>{t.owner!==null&&!t.isEnergyTower&&(e.has(t.owner)||e.set(t.owner,[]),e.get(t.owner).push({...t,id:r}))});for(const[t,r]of e){const o=r.reduce((l,a)=>l+a.socialConnections.length,0);if(o===0)continue;const i=this.nodes.filter(l=>l.isEnergyTower&&l.owner===t).length*m;r.forEach(l=>{const a=l.socialConnections.length/o,c=Math.min(Math.floor(i*a),l.socialConnections.length),d=this.nodes[l.id];d.currentEnergy=0;for(let f=0;f<c&&this.tryIncreaseNodeEnergy(l.id);f++);})}}newGame(){this.currentPlayer=0,this.turn=1,this.selectedNode=null,this.dragStart=null,this.gameOver=!1,this.mouseX=0,this.mouseY=0,this.lastHoveredNode=null,this.lastHoveredPowerline=null,this.players=Array.from({length:g},(e,t)=>({energy:I,color:`hsl(${t*360/g}, 100%, 50%)`,towerId:t,energyDraining:0,energyGenerated:m,nodesSuppliedTo:[]})),this.init()}checkVictoryCondition(){const t=this.nodes.length*.6,r=Array(g).fill(0);for(const o of this.nodes)o.owner!==null&&o.owner>=0&&o.owner<g&&r[o.owner]++;for(let o=0;o<g;o++)if(r[o]>=t){this.gameOver=!0,se(o);return}}}function O(n,e){const t=e.getBoundingClientRect();return{x:n.clientX-t.left,y:n.clientY-t.top}}function we(n,e,t){return t.find(r=>r.from===n&&r.to===e||r.from===e&&r.to===n)}function ge(n,e,t){const r=n.players[n.currentPlayer],o=r.towerId;B(o,e.id,n.powerEdges,n.currentPlayer)&&(t&&e.currentEnergy>0?n.tryDecreaseNodeEnergy(e.id):!t&&r.energy>0&&n.tryIncreaseNodeEnergy(e.id))}function k(n,e,t=!1){if(!e||e.gameOver)return;const{x:r,y:o}=O(n,e.canvas),s=P(r,o,e);s&&(e.selectedNode=s,s.isEnergyTower||ge(e,s,t)),A(e),C(e)}function ye(n,e){if(!e||e.gameOver)return;const{x:t,y:r}=O(n,e.canvas),o=P(t,r,e);o&&(e.dragStart=o)}function pe(n,e){if(!e)return;const{x:t,y:r}=O(n,e.canvas);e.mouseX=t,e.mouseY=r;const o=P(t,r,e),s=e.lastHoveredNode||e.lastHoveredPowerline;e.lastHoveredNode=o,o?e.canvas.style.cursor="pointer":e.dragStart?e.canvas.style.cursor="grabbing":e.canvas.style.cursor="default",(e.dragStart||o||s)&&C(e)}function Ee(n,e,t){const r=n.players[n.currentPlayer],o=T(e,t),s=G-M,i=M+Math.floor(Math.random()*s),l=Math.floor(o/V)+i;if(r.energy<l)return;const a=we(e.id,t.id,n.powerEdges);a?a.owner===n.currentPlayer&&(a.capacity+=i,r.energy-=l):n.tryConstructEdge(e.id,t.id,n.currentPlayer,i,l)}function ve(n,e){if(!e||e.gameOver||!e.dragStart)return;const{x:t,y:r}=O(n,e.canvas),o=P(t,r,e);o&&o!==e.dragStart&&Ee(e,e.dragStart,o),e.dragStart=null,e.canvas.style.cursor="default",A(e),C(e)}const y=document.getElementById("gameCanvas");let u=null;window.onload=()=>{const n=()=>{y.width=y.clientWidth,y.height=y.clientHeight,u!=null&&u.nodes&&u.nodes.length>0&&C(u)};window.addEventListener("resize",n),n(),y.addEventListener("click",e=>k(e,u)),y.addEventListener("contextmenu",e=>{e.preventDefault(),k(e,u,!0)}),y.addEventListener("mousedown",e=>ye(e,u)),y.addEventListener("mousemove",e=>pe(e,u)),y.addEventListener("mouseup",e=>ve(e,u)),Te()};function Te(){u=new fe;const n=document.getElementById("endTurnBtn"),e=document.getElementById("newGameBtn"),t=document.getElementById("anewGameBtn");n&&n.addEventListener("click",()=>u==null?void 0:u.nextTurn()),e&&e.addEventListener("click",()=>u==null?void 0:u.newGame()),t&&t.addEventListener("click",()=>u==null?void 0:u.newGame())}
